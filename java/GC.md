# GC

**updated 2023.02.21**

- 참고 자료 : [Introduction to Garbage Collection](https://dev.java/learn/jvm/tool/garbage-collection/intro/)

<hr/>

목차

- [GC(Garbage Collection, 가비지 컬렉션)이란?](#gcgarbage-collection-가비지-컬렉션이란)
- [GC가 garbage 여부를 판단하는 기준](#gc가-garbage-여부를-판단하는-기준)
  - [쓰레기 수거 프로세스 3단계!](#쓰레기-수거-프로세스-3단계)
  - [generational garbage collectors의 힙 영역 사용 전략](#generational-garbage-collectors의-힙-영역-사용-전략)
- [GC 종류 : Types of Garbage Collections](#gc-종류--types-of-garbage-collections)
- [또 다른 GC 종류 : Types of Generational Garbage Collectors](#또-다른-gc-종류--types-of-generational-garbage-collectors)
<hr/>

## GC(Garbage Collection, 가비지 컬렉션)이란?

### 요약

Java에서 말하는 GC는 JVM 내부 프로그램으로, 더이상 사용하지 않는 객체에 할당된 메모리를 개발자 대신 해제 해주는 프로그램을 말한다.

- Memory Managment 관점

  - 컴퓨터 과학에서 GC는 메모리 관리의 한 형태이다. (Java에만 GC가 있는게 아니다. 다른 언어에서도 GC는 존재한다.)
  - 더 알아보기 : [위키 : Garbage collection ](<https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)>)

- Java의 메모리 관리

  - Java 내에서 메모리 관리는 JVM(Java Virtual Machine)의 일부인 가비지 수집기에 의해 처리됩니다. **JVM 내에서 가비지 수집기는 메모리의 개체를 모니터링하는 백그라운드 프로세스입니다.**
  - 주기적으로 가비지 수집기는

    1. 메모리의 개체에 여전히 도달할 수 있는지 확인하고,
    2. 도달할 수 없는 개체를 제거하고,
    3. 메모리를 보다 효율적으로 사용하고 향후 가비지 수집을 개선하기 위해 아직 살아있는 개체를 재구성하는 가비지 수집을 실행합니다.

  - 목적
    - 가비지 컬렉터는 개발자가 메모리 관리에 소비해야 하는 시간과 노력을 상당히 줄여줍니다. 종종 개발자는 메모리 관리를 의식적으로 고려할 필요가 없습니다.
    - 가비지 수집은 또한 **메모리 누수와 같은 문제를 제거하지는 않지만** 크게 줄이는 데 도움이 됩니다.

<hr>

## GC가 garbage 여부를 판단하는 기준

### 요약

Mark단계에서 Root 개체를 통해 도달 할 수 없는 개체들은 garbage로 판단된다.

### 쓰레기 수거 프로세스 3단계!

**mark! sweep! and compaction!** 표시하고, 빗질하고, 압축하라!

- #### Mark 표시하라

  - 객체 생성 시 모든 객체는 VM에 의해 1비트 표시 값으로 제공되며 처음에는 false( 0)로 설정됩니다. 이 값은 가비지 수집기가 개체에 도달할 수 있는지 여부를 표시하는 데 사용됩니다. 가비지 수집이 시작될 때 **가비지 수집기는 개체 그래프를 순회**하고 도달할 수 있는 모든 개체를 true( 1)로 표시합니다
  - > ##### **개체 그래프** 순환(traverses the object graph) 이란 ?
    >
    > ##### 컴퓨터 과학 의 객체 지향 프로그램 에서 객체 그룹(object graph)은 다른 객체에 대한 직접 참조 또는 중간 참조 체인을 통해 서로 간의 관계를 통해 네트워크를 형성합니다 . 이러한 개체 그룹은 그래프 이론 에서 연구한 그래프 라는 수학적 개체를 따서 개체 그래프 라고 합니다 .
  - <img src="https://dev.java/assets/images/mark-phase-i.gif" alt="traverses the object graph" />

  - 가비지 수집기는 각 개체를 개별적으로 검사하지 않고 대신 **"루트" 개체**에서 시작합니다.
  - 루트 개체의 예는 다음과 같습니다.
    - 로컬 변수
    - 정적 클래스 필드
    - 활성 Java 스레드 및
    - JNI 참조.
  - 위쪽의 애니메이션은 객체 표시 단계의 모습을 시각화합니다

  ```
   궁금한 점.
   루트 개체 예시에 거론된 4가지 개체들은 각각 메모리상 어느 영역에 속해 있는지 궁금함.

   잘 모르겠는점.
   JNI 이란?

  ```

- #### Sweep 빗질하라 (쓸어내서 제거하라)

  - 스윕 단계 동안 도달할 수 없는 모든 개체, 현재 표시 비트가 거짓( 0)인 개체는 *제거*됩니다.

- #### compaction 압축하라

  - 가비지 수집의 마지막 단계는 _압축_ 단계입니다.
  - _에덴_ 영역 또는 점유된 서바이버 영역의 살아있는 객체는 빈 서바이버 영역으로 이동 및/또는 복사됩니다.
  - _서바이버_ 영역의 개체가 충분한 소유권을 얻은 경우 _올드_ 영역으로 이동하거나 복사됩니다

  ```
   더 조사할 점
   - 에덴, 서바이버, 올드 영역에 대한 기본 지식.
   - 점유된 서바이버 영역 이란 무엇을 의미 하는지?
  ```

  ### generational garbage collectors의 힙 영역 사용 전략

  Java의 대부분의 가비지 수집기는generational garbage collectors (Z GC를 제외한 모든 가비지 수집기)로 구현됩니다.

  generational garbage collectors의 기본 개념은 **대부분의 개체가 수명이 짧고 생성 후 곧 제거해야 한다는 것**입니다. 또는 개체의 *수명이 늘어남에 따라 제거 대상이 될 가능성이 점점 낮아*집니다.

  세대별 가비지 수집기는 **힙을 여러 영역으로 나눕니다.** 새 개체는 더 자주 확인되는 Young Region에, 수명이 긴 개체는 덜 자주 확인되는 Old Region 영역에 있습니다.

  1. Young Region - 이름에서 알 수 있듯이 젊은 영역은 최근에 생성된 개체를 포함하는 힙 영역입니다. Young 지역 자체는 더 많은 지역으로 세분화됩니다.
     1. Eden 공간 - 초기 생성 시 개체는 첫 번째 가비지 수집까지 힙의 Eden 영역에 저장됩니다.
     2. 서바이버 공간 - 가비지 컬렉션에서 살아남은 객체는 서바이버 영역으로 승격됩니다. 세대별 수집기에는 가비지 수집기 효율성을 개선하기 위한 목적으로 여러 생존 영역이 있습니다. 가비지 수집 중에 여전히 Eden 공간 또는 점유된(occupied:가득차 있는) 서바이버 공간에 있는 참조되는 개체는 빈 생존자 공간으로 복사 또는 이동합니다.
  2. Old Region - 개체가 가비지 수집을 유지하여 충분한 "연령"을 얻으면 이전 지역으로 승격됩니다.

  3. Permanent/Metaspace Region (영구/메타스페이스 영역) - 마지막 영역은 영구 또는 메타스페이스 영역입니다. 여기에 저장되는 개체는 일반적으로 JVM 메타데이터, 핵심 시스템 클래스 및 일반적으로 JVM 수명의 거의 전체 기간 동안 존재하는 기타 데이터입니다. 이 영역에 저장된 객체는 종종 힙이 중요한 소비 메모리 임계값에 도달한 경우에만 가비지 수집기에 의해 확인됩니다.

<hr/>

## GC 종류 : Types of Garbage Collections

다양한 힙 메모리 영역이 있는 것처럼 다양한 유형의 가비지 컬렉션도 있습니다.

- Minor - Minor 가비지 수집은 **힙 메모리의 Young 영역만 스캔**합니다. 사소한 가비지 수집은 매우 자주 발생하며 관련 일시 중지 시간이 매우 짧은 경우가 많습니다.
- Major - 주요 가비지 컬렉션은 **힙 메모리의 Young 및 Old 영역을 모두 검색**합니다. 메이저 가비지 컬렉션은 마이너 가비지 컬렉션보다 훨씬 덜 자주 발생하며, 예를 들어 힙 메모리의 임계값이 사용된 경우와 같이 VM 내의 특정 조건에 의해 트리거되는 경우가 많습니다. 훨씬 더 긴 일시 중지 시간은 힙의 훨씬 더 많은 부분이 스캔되고 있으므로 주요 가비지 수집과 관련됩니다.
- Full - 전체 가비지 수집은 **전체 힙, Young, Old 및 Permanent/Metaspace 영역을 스캔하는 경우**입니다. 주요 가비지 수집과 마찬가지로 전체 가비지 수집은 예를 들어 매우 높은 비율의 힙 메모리가 소비되거나 시스템 관리자가 수동으로 수행하는 경우와 같은 조건을 기반으로 하는 경우가 많습니다. 또한 주요 가비지 수집과 마찬가지로 매우 긴 일시 중지 시간은 전체 가비지 수집과 관련됩니다.

<hr/>

## 또 다른 GC 종류 : Types of Generational Garbage Collectors

### 요약

하드웨어 성능에 따라 최적화된 가비지 컬렉터의 유형이 있다.
JDK 9 이후 기본값은 **Garbage First(G1) Garbage Collector**이다.

### 세대별 가비지 수집기 유형

HotSpot JVM 내에서 Garbage Collector는 단일 통합 개념이 아니지만 여러 구현이 있습니다. 사용할 가비지 수집기 구현은 사용 가능한 하드웨어 리소스와 애플리케이션의 성능 요구 사항에 따라 다릅니다.

- 직렬 가비지 수집기 - 단일 스레드에서 모든 가비지 수집을 수행합니다. 일시 중지 시간은 더 길지만 리소스 사용량은 더 적습니다. 단일 프로세서만 있는 시스템에서 가장 잘 사용됩니다.
- 병렬 가비지 수집기 - 직렬 가비지 수집기와 유사하지만 여러 스레드를 사용하여 작업을 수행하여 일시 중지 시간을 줄입니다.
- CMS(Concurrent Mark Sweep) 가비지 수집기 (JDK 9에서는 사용되지 않음, JDK 14에서는 제거됨) - 응용 프로그램이 실행되는 동안 개체 사용을 추적하는 백그라운드 프로세스를 통해 가비지 수집 일시 중지 시간을 줄입니다.
- **Garbage First(G1) Garbage Collector** (JDK 9 이후 기본값) - CMS GC를 개선하고 대체합니다. G1은 대용량 메모리에 액세스할 수 있는 다중 프로세서 시스템에 이상적으로 적합합니다.
- Z GC (JDK 11에서 실험적, JDK 15에서 프로덕션) - 멀티 테라바이트 힙이 있는 애플리케이션을 위해 확장할 수도 있는 초저지연 GC입니다. GC의 내부 구현 및 동작은 나열된 다른 가비지 수집기와는 분명히 다르며 동작에 대한 설명은 별도의 문서에서 처리됩니다.
